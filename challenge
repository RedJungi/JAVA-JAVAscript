// 자바 기초, 자바 기본 문법 마스터하기


// 클래스 선언
public class MyClass {
    // 변수 선언
    int num1;
    Message msg;

    // 메서드
    public void printName(String name) {
        ...
    }

    // 메서드
    public Message getMessage() {
        ...
    }

    // 메인 메서드
    public static void main(String[] args) {
        // 클래스 인스턴스 생성
        MyClass mc = new MyClass();
        ...
    }
}

클래스(class)
객체지향 프로그램의 기본 구조로 자바에서 모든 프로그램 소스는 클래스 단위로 시작하게 된다.
// 프로그램 소스는 .java 파일이고 컴파일된 결과는 .class 가 된다.
// 알번적으로 클래스 이름과 소스파일명은 동일함.
// 대부분의 경우 프로그램은 여러 클래스로 구성되며 실행을 위해서는 main() 메서드가 필요함.

인스턴스(instance)
클래스로 부터 생성된 객체로 클래스는 객체를 정의한 틀이고 실제 프로그램은 인스턴스를 통해 동작하게된다.
// main() 메서드는 단지 프로그램을 실행하는 진입점이고 실제 클래스를 사용하려면 new() 연산을 통해 인스턴스를 생성해야한다.
// main() 에서 클래스부에 선언된 변수(멤버)를 접근할 수 없으며 인스턴스를 통해 사용해야함(인스턴스 변수).
// 인스턴스에서 변수와 메서드 사용은 인스턴스명.변수명 , 인스턴스명,메서드명 과 같은 형식으로 사용.

변수는 데이터를 저장하기 위한 메모리 공간에 대한 이름으로 저장할 데이터의 크기를 알아야 필요한 공간을 확보할 수 있습니다. 따라서 적절한 자료형을 사용하는 것은 매우 중요합니다.
다만 객체지향 프로그램 언어에서는 클래스 타입을 자료형으로 사용할 수 있으며 최근에 나오는 언어들의 경우 메모리 공간의 크기를 계산하기 위한 용도라기 보다는 타입을 구분하는 개념으로 접근하고 있습니다. 
나아가 타입에 대한 추론을 통해 개발자가 타입에 신경쓰지 않고 코딩을 할 수 있도록 지원하고 있습니다.
자바의 경우 원시 자료형(Primitive Type)과 클래스 타입(Class Type)을 모두 지원 하고 있으며 원시 자료형에 대한 클래스 타입들은 랩퍼 클래스(Wrapper Class)라고 합니다.

[접근제어자] 타입 변수명

int num1 = 10;      // 원시자료형 정수 타입
String msg = "Hello";   // 객체타입 문자열 타입
Member member = new Member();   // 객체타입 Member 클래스 타입

접근제어자: 변수의 접근범위를 지정
타입: 자료형으로 자바는 명시적으로 타입을 지정해야 함.
자료형에는 원시자료형과 객체형이 있으며 객체타입의 변수는 참조변수라고 함.
객체지향에서는 클래스부에 선언된 변수는 필드 혹은 멤버 변수라고 함.

[연산자]는 프로그램에서 변수의 값들을 계산하기 위해 사용 한다.
사칙연산, 대입연산, 비트연산, 논리연산, 관계연산 등이 있다.

조건문
(if문)
// if, else if
if(power < 10) {
    slowdown();
}
else if((power > 100) && (time <= 50) {
    gofaster();
}
else {
    go();
}

(switch문)
switch(입력 변수) {
    case 조건값: 실행 구문;break;
    ..
    default: 기본 실행 구문;
}

(배열 선언 기본)
int scores[] = {95,100,87,91};
int[] scores = {95,100,87,91};
int[] scores = new int[4];
scores[2] = 90; // 3번째 요소(87)을 90으로 변경.

System.out.println(scores[0]);

자바에서 배열선언시 타입[] 변수명 혹은 타입 변수명[] 형식을 모두 사용할 수 있음.
배열선언시 크기를 지정하거나 초기 데이터로 크기가 고정됨.
배열원소에 접근은 배열명[인덱스] 형식으로 사용.
인덱스는 0부터 시작.
배열.length 를 통해 배열의 크기를 구할 수 있음

(키보드 입력, 로깅)
Scanner scan = new Scanner(System.in);
String name = scan.next();
int num = scan.nextInt();

Scanner 객체 생성시 입력 스트림을 지정할 수 있음(키보드 이외 파일이나 네트워크도 가능)
입력값을 문자열로 반환하는 next()를 비롯해 nextByte(), nextInt() 등 데이터 타입에 따른 메서드 존재
입력값이 공백으로 구분되어 한줄로 입력될 경우 공백을 기준으로 다음 데이터를 찾게됨
따라서 한줄 전체를 문자열 입력으로 처리하려면 nextLine()을 사용해야함
hasNext() 는 다음 데이터가 있는지 true/false 로 알려줌

{객체지향}

클래스(Class)
클래스는 객체를 정의하기 위한 틀로써 표현하고자 하는 객체들의 속성과 동작을 정의하고 있습니다.
앞의 소나타 예에서 소나타는 Car 라고 하는 클래스로 정의할 수 있는 것

class Car {
    String color;
    String model;
    int power;

    public void go() {
    }

    public void break() {
    }
}

상속은 바로 클래스간의 상하 관계로 추상적인 슈퍼클래스(Super Class) 
혹은 부모 클래스로 부터 서브클래스(Sub Class) 혹은 자식 클래스를 만드는 것으로 상속이라는 관계를 통해 계층구조를 형성하게 합니다.

(클래스 상속의 특징)
슈퍼 클래스에서 정의된 필드와 메서드를 물려 받는다.
새로운 필드나 메서드를 추가할 수 있다.
슈퍼 클래스에서 물려 받은 메서드를 수정할 수 있다.(오버라이딩, Overriding)
동일 슈퍼클래스를 상속하는 모든 서브클래스는 타입 호환이 된다.

(오버라이딩)
슈퍼클래스로 부터 상속받은 메서드를 다시 정의하는 것을 말합니다. 당연히 메서드의 이름과 리턴 타입, 인자등이 모두 동일해야 하며 다를 경우 새로운 메서드가 추가되는 형식이 된다.

오버라이딩을 통해 객체지향의 특징중 하나인 다형성 구현이 가능해 집니다. 예를들어 애완동물 클래스가 있고 bark() 라는 메서드가 있다고 했을때 애안동물 클래스를 상속받는 강아지와 
고양이 클래스를 만들경우 bark() 메서드의 오버라이딩을 통해 서로 다른 동작이 가능하게 할 수 있다.

Class SubClass extends SuperClass {

}

class Pet {
    void bark() {
        System.out.println("pipi");
    }
}

class Dog extends Pet {
    void bark() {
        System.out.println("woof woof");
    }
}

class Cat extends Pet {
        void bark() {
        System.out.println("mew mew");
    }
}

(추상클래스)
추상클래스는 추상메서드(abstract method)를 포함하고 있는 클래스를 말한다. 
추상메서드란 앞의 Pet 클래스와 같이 구체적이지 않은 내용을 정의한 메서드를 말하는 것으로 추상 메서드로 정의된 메서드는 서브 클래스에서 반드시 오버라이딩을 통해 구현해야 한다.

따라서 추상클래스 자체는 new 를 통해 인스턴스로 만들 수 없고 반드시 상속을 통해 구체적인 클래스를 만들어 사용해야 한다. 
소프트웨어 디자인 패턴에서는 이렇게 추상클래스를 상속해서 구현하는 클래스를 콘크리트 클래스(Concrete Class) 라고도 부른다.
추상클래스는 추상메서드 이외에 다른 메서드를 포함할 수 있으면 멤버 필드역시 가질 수 있습니다. 앞의 Pet 클래스를 추상클래스로 정의 하면 다음과 같이 된다.

abstract class Pet {
    abstract void bark(){};
}

참고로 메서드의 abstact 와 바디부 표시인 {}는 생략이 가능하다.
이클립스와 같은 개발도구를 사용하는 경우 추상클래스 상속시 자동으로 추상메서드 구현을 알려주고 기본 코드를 생성해 구현부를 작성할 수 있도록 도와주게 된다.

(인터페이스)
인터페이스는 말 그대로 무언가를 이어주기 위한 연결고리로 추상클래스와 유사하지만 상수와 추상메서드로만 구성된 형태를 말합니다. 
추상메서드로만 구성이 되기 때문에 그 자체로는 아무런 기능을 하지 않지만 마치 설계도 처럼 향후 구현될 클래스들을 연결해 사용할 수 있는 기반 구조를 제공하고 있다.

멤버필드는 모두 public static final 만 가능하며 제어자는 생략이 가능.
모든 메서드는 public abstract 만 가능하며 제어자는 생략이 가능

interface Pet {
    void bark();
}

추상클래스와 달리 인터페이스는 상속(extends)이 아니라 구현(implements)을 통해 클래스를 정의하게 된다.
class Dog implements Pet {
    ...
}

또한 일반적인 클래스들은 다중상속이 안되지만 인터페이스의 경우 다중 구현이 가능하다. 
예를들어 로봇 애완견을 만들기 위해 Pet 과 Robot 인터페이스를 동시에 구현할 수 있다.
class RobotDog implments Pet, Robot {
    ...
}

이경우 양쪽 인터페이스 모두의 추상메서드가 구현되어야 한다. 
또한 상속받을 클래스가 있다면 상속과 함께 사용하는 것도 가능하다.

class RobotCat extends Pet implements Robot {
    ...
}

일반적으로 설계의 관점에서는 인터페이스를 사용하고 구현시 유연함을 위해서는 추상클래스를 사용할 수 있다.

다만 JDK 8 에서 추가된 default 를 이용하면 인터페이스에 메서드 구현이 가능하고 이를 구현하는 
클래스에서 해당 메서드의 오버라이딩도 가능해져 사실상 추상클래스의 역할을 겸하게 되었다고 볼 수 있다.

추가적으로 static 메서드의 구현도 가능해져 인터페이스의 활용도가 높아졌다고 볼 수 있다. 
물론 실제 구현에는 추상클래스, 인터페이스 등이 모두 혼재해서 사용되고 있으니 필요에 따라 적절히 선택해 사용하면 된다.

interface Pet {
    void bark();
    default eat(int amount) {
        ...
    };
    static void wake() {
        ....
    }
}

bark() 는 구현 클래스에서 반드시 구현해야 하는 추상 메서드
eat(int amount) 는 기본제공되는 메서드로 필요시 오버라이딩 가능
wake() 는 static 메서드로 구현클래스 없이 Pet.wake() 로 사용 가능

패키지는 자바 클래스들을 구분하기 위해 사용한다. 객체지향 프로그래밍에서는 여러 클래스들이 사용되고 내가 직접 만들지 않은 클래스 혹은 라이브러리들을 사용하는 경우도 많이 있다.
이때 클래스들의 이름이 모두 동일하다면 문제가 발생할 수 있다.

예를들어 회원관리 프로그램에 Login 클래스가 있을수 있으며 카페나 블로그, 쇼핑몰 쪽에서도 Login 클래스가 있을수 있다. 
이처럼 서로 다른 목적에서 개발된 클래스들을 서로 구분하기 위해 패키지를 사용하게 된다.

그리고 이러한 패키지들을 전세계적으로 문제 없이 관리하기 위한 일종의 규약이 존재하는데 패키지 이름의 관리를 역도메인(reverse domain) 방식으로 하는 것이다.

도메인은 인터넷에서 기관을 이름으로 구분한 것인데 패키지는 이를 뒤집어서 사용하게 된다.

예를들어 네이버의 도메인은 naver.com 인데 만일 네이버 개발자들이 자바 클래스를 개발하게 된다면 com.naver 를 루트 패키지명으로 사용하게 되는것이다. 
실제 네이버는 카페, 블로그, 메일 등과 같은 서비스를 운영하고 있기 때문에 이들에 사용되는 클래스들은 각각 com.naver.cafe, com.naver.blog, com.naver.mail
과 같은 패키지명을 사용하게 되는 것이다.

(package 선언)
package com.my.study;

class MyClass {

}

(package import)
현재 구현중인 클래스에서 동일패키지에 있는 클래스가 아닌 다른 클래스(외부 라이브러리 등)를 사용하는 경우 반드시 import 문을 사용해 해당 클래스의 패키지를 명시해 주어야 한다.
만일 import 문을 사용하지 않는다면 소스코드에서 해당 클래스 사용시 매번 클래스 이름 앞에 패키지명까지 붙여주어야 한다.

class MyClass {
 java.util.Scanner scan = new java.util.Scanner(System.in);   
}

대부분의 경우 매번 패키지명을 붙여주는 방식 보다는 해당 클래스의 패키지를 import 해주는 방법을 사용한다.

import java.util.Scanner;

class MyClass {
    Scanner scan = new Scanner(System.in);
}

원칙적으로는 사용되는 모든 클래스를 import 해주는 것이며 특정 패키지의 모든 클래스를 한번에 import 하기 위해서는 다음과 같이 *을 사용하기도 한다.

import java.util.*;

그러나 이러한 방식은 많은 라이브러리를 동시에 사용하는 경우 클래스 이름 중복으로 인한 문제가 발생할 수 있으므로 주의해야 한다. 
보통은 개발도구에서 자동으로 패키지 import 를 관리하므로 신경쓰지 말고 개별 클래스들이 import 될 수 있도록 하는 것이 좋다.

실제 패키지는 디스크 상에는 디렉토리 개념으로 소스 폴더를 열어보면 com 폴더 아래 my 폴더가 있고 그아래 study 폴더에 자바 소스파일들이 위치한 것을 확인할 수 있다.
